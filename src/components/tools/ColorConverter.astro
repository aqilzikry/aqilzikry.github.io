---
// src/components/tools/ColorConverter.astro
---

<div class='space-y-6'>
  <div>
    <label for='hexInput' class='block text-lg font-medium text-light dark:text-gray-300'>HEX Color:</label>
    <input
      type='text'
      id='hexInput'
      name='hexInput'
      placeholder='#fefefe'
      class='mt-1 block w-full px-3 py-2 bg-white dark:bg-dark border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue focus:border-blue sm:text-sm text-dark dark:text-light'
    />
  </div>

  <div>
    <label for='rgbInput' class='block text-lg font-medium text-light dark:text-gray-300'>RGB Color:</label>
    <input
      type='text'
      id='rgbInput'
      name='rgbInput'
      placeholder='rgb(254, 254, 254)'
      class='mt-1 block w-full px-3 py-2 bg-white dark:bg-dark border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue focus:border-blue sm:text-sm text-dark dark:text-light'
    />
  </div>

  <div>
    <label for='hslInput' class='block text-lg font-medium text-light dark:text-gray-300'>HSL Color:</label>
    <input
      type='text'
      id='hslInput'
      name='hslInput'
      placeholder='hsl(0, 0%, 100%)'
      class='mt-1 block w-full px-3 py-2 bg-white dark:bg-dark border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue focus:border-blue sm:text-sm text-dark dark:text-light'
    />
  </div>

  <div class='h-24 w-full rounded-md border border-gray-300 dark:border-gray-600' id='colorPreview'></div>
</div>

<script>
  const hexInput = document.getElementById('hexInput') as HTMLInputElement;
  const rgbInput = document.getElementById('rgbInput') as HTMLInputElement;
  const hslInput = document.getElementById('hslInput') as HTMLInputElement;
  const colorPreview = document.getElementById('colorPreview') as HTMLDivElement;

  // Set default color
  colorPreview.style.backgroundColor = '#fefefe';

  // Debounce function to limit rapid updates
  function debounce(func, delay) {
    let timeout;
    return function (...args) {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), delay);
    };
  }

  function updateColorPreview(colorString) {
    if (colorPreview) {
      try {
        colorPreview.style.backgroundColor = colorString;
      } catch (e) {
        // if the color string is invalid, don't crash, just don't update preview
        colorPreview.style.backgroundColor = 'transparent';
      }
    }
  }

  // --- HEX Conversions ---
  function hexToRgb(hex) {
    hex = hex.replace(/^#/, '');
    if (!/^[0-9A-Fa-f]{6}$/.test(hex) && !/^[0-9A-Fa-f]{3}$/.test(hex)) return null;
    if (hex.length === 3) {
      hex = hex
        .split('')
        .map((char) => char + char)
        .join('');
    }
    const bigint = parseInt(hex, 16);
    const r = (bigint >> 16) & 255;
    const g = (bigint >> 8) & 255;
    const b = bigint & 255;
    return { r, g, b };
  }

  function hexToHsl(hex) {
    const rgb = hexToRgb(hex);
    return rgb ? rgbToHsl(rgb.r, rgb.g, rgb.b) : null;
  }

  // --- RGB Conversions ---
  function rgbToHex(r, g, b) {
    if (isNaN(r) || isNaN(g) || isNaN(b)) return null;
    if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255) return null;
    return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
  }

  function rgbToHsl(r, g, b) {
    if (isNaN(r) || isNaN(g) || isNaN(b)) return null;
    r /= 255;
    g /= 255;
    b /= 255;
    const max = Math.max(r, g, b),
      min = Math.min(r, g, b);
    let h,
      s,
      l = (max + min) / 2;
    if (max === min) {
      h = s = 0; // achromatic
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
          break;
      }
      h /= 6;
    }
    return { h: Math.round(h * 360), s: Math.round(s * 100), l: Math.round(l * 100) };
  }

  // --- HSL Conversions ---
  function hslToRgb(h, s, l) {
    if (isNaN(h) || isNaN(s) || isNaN(l)) return null;
    h = h % 360;
    if (h < 0) h += 360;
    s /= 100;
    l /= 100;
    if (s < 0 || s > 1 || l < 0 || l > 1) return null;

    const k = (n) => (n + h / 30) % 12;
    const a = s * Math.min(l, 1 - l);
    const f = (n) => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
    return {
      r: Math.round(255 * f(0)),
      g: Math.round(255 * f(8)),
      b: Math.round(255 * f(4)),
    };
  }

  function hslToHex(h, s, l) {
    const rgb = hslToRgb(h, s, l);
    return rgb ? rgbToHex(rgb.r, rgb.g, rgb.b) : null;
  }

  // --- Input Parsers ---
  function parseRgbString(rgbStr) {
    const match = rgbStr.match(/^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/i);
    return match ? { r: parseInt(match[1]), g: parseInt(match[2]), b: parseInt(match[3]) } : null;
  }

  function parseHslString(hslStr) {
    const match = hslStr.match(/^hsl\((\d{1,3}),\s*(\d{1,3})%,\s*(\d{1,3})%\)$/i);
    return match ? { h: parseInt(match[1]), s: parseInt(match[2]), l: parseInt(match[3]) } : null;
  }

  // --- Event Handlers (Debounced) ---
  const handleHexInput = debounce(() => {
    const hex = hexInput.value.trim();
    if (!hex) {
      rgbInput.value = '';
      hslInput.value = '';
      updateColorPreview('transparent');
      return;
    }
    const rgb = hexToRgb(hex);
    const hsl = hexToHsl(hex);
    rgbInput.value = rgb ? `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})` : 'Invalid HEX';
    hslInput.value = hsl ? `hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)` : 'Invalid HEX';
    if (rgb) updateColorPreview(`#${hex.replace(/^#/, '')}`);
    else updateColorPreview('transparent');
  }, 300);

  const handleRgbInput = debounce(() => {
    const rgbObj = parseRgbString(rgbInput.value.trim());
    if (!rgbObj) {
      hexInput.value = rgbInput.value.trim() ? 'Invalid RGB' : '';
      hslInput.value = rgbInput.value.trim() ? 'Invalid RGB' : '';
      if (!rgbInput.value.trim()) updateColorPreview('transparent');
      return;
    }
    const hex = rgbToHex(rgbObj.r, rgbObj.g, rgbObj.b);
    const hsl = rgbToHsl(rgbObj.r, rgbObj.g, rgbObj.b);
    hexInput.value = hex || 'Invalid RGB';
    hslInput.value = hsl ? `hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)` : 'Invalid RGB';
    if (hex) updateColorPreview(hex);
    else updateColorPreview('transparent');
  }, 300);

  const handleHslInput = debounce(() => {
    const hslObj = parseHslString(hslInput.value.trim());
    if (!hslObj) {
      hexInput.value = hslInput.value.trim() ? 'Invalid HSL' : '';
      rgbInput.value = hslInput.value.trim() ? 'Invalid HSL' : '';
      if (!hslInput.value.trim()) updateColorPreview('transparent');
      return;
    }
    const hex = hslToHex(hslObj.h, hslObj.s, hslObj.l);
    const rgb = hslToRgb(hslObj.h, hslObj.s, hslObj.l);
    hexInput.value = hex || 'Invalid HSL';
    rgbInput.value = rgb ? `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})` : 'Invalid HSL';
    if (hex) updateColorPreview(hex);
    else updateColorPreview('transparent');
  }, 300);

  // --- Attach Event Listeners ---
  hexInput.addEventListener('input', handleHexInput);
  rgbInput.addEventListener('input', handleRgbInput);
  hslInput.addEventListener('input', handleHslInput);

  // Clear other fields if one is cleared
  [hexInput, rgbInput, hslInput].forEach((input) => {
    input.addEventListener('input', () => {
      if (input.value.trim() === '') {
        if (input !== hexInput) hexInput.value = '';
        if (input !== rgbInput) rgbInput.value = '';
        if (input !== hslInput) hslInput.value = '';
        updateColorPreview('transparent');
      }
    });
  });
</script>
